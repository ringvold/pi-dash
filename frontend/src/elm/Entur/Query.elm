-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Entur.Query exposing (AuthorityRequiredArguments, BikeParkRequiredArguments, BikeRentalStationRequiredArguments, BikeRentalStationsByBboxOptionalArguments, CarParkRequiredArguments, CarParksOptionalArguments, LineRequiredArguments, LinesOptionalArguments, NearestOptionalArguments, NearestRequiredArguments, OperatorRequiredArguments, OrganisationRequiredArguments, QuayRequiredArguments, QuaysByBboxOptionalArguments, QuaysByRadiusOptionalArguments, QuaysOptionalArguments, ServiceJourneyRequiredArguments, ServiceJourneysOptionalArguments, StopPlaceRequiredArguments, StopPlacesByBboxOptionalArguments, StopPlacesOptionalArguments, TripOptionalArguments, TripRequiredArguments, authorities, authority, bikePark, bikeParks, bikeRentalStation, bikeRentalStations, bikeRentalStationsByBbox, carPark, carParks, line, lines, nearest, notices, operator, operators, organisation, organisations, quay, quays, quaysByBbox, quaysByRadius, routingParameters, selection, serviceJourney, serviceJourneys, situations, stopPlace, stopPlaces, stopPlacesByBbox, trip)

import Entur.Enum.FilterPlaceType
import Entur.Enum.Locale
import Entur.Enum.Mode
import Entur.Enum.MultiModalMode
import Entur.Enum.OptimisationMethod
import Entur.Enum.TransportMode
import Entur.InputObject
import Entur.Interface
import Entur.Object
import Entur.Scalar
import Entur.Union
import Graphql.Field as Field exposing (Field)
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


{-| Select fields to build up a top-level query. The request can be sent with
functions from `Graphql.Http`.
-}
selection : (a -> constructor) -> SelectionSet (a -> constructor) RootQuery
selection constructor =
    Object.selection constructor


type alias TripOptionalArguments =
    { dateTime : OptionalArgument Entur.Scalar.DateTime, wheelchair : OptionalArgument Bool, numTripPatterns : OptionalArgument Int, maximumWalkDistance : OptionalArgument Float, walkSpeed : OptionalArgument Float, bikeSpeed : OptionalArgument Float, optimisationMethod : OptionalArgument Entur.Enum.OptimisationMethod.OptimisationMethod, arriveBy : OptionalArgument Bool, vias : OptionalArgument (List (Maybe Entur.InputObject.Location)), preferred : OptionalArgument Entur.InputObject.InputPreferred, unpreferred : OptionalArgument Entur.InputObject.InputUnpreferred, banned : OptionalArgument Entur.InputObject.InputBanned, whiteListed : OptionalArgument Entur.InputObject.InputWhiteListed, transferPenalty : OptionalArgument Int, modes : OptionalArgument (List (Maybe Entur.Enum.Mode.Mode)), transportSubmodes : OptionalArgument (List (Maybe Entur.InputObject.TransportSubmodeFilter)), allowBikeRental : OptionalArgument Bool, minimumTransferTime : OptionalArgument Int, maximumTransfers : OptionalArgument Int, ignoreRealtimeUpdates : OptionalArgument Bool, includePlannedCancellations : OptionalArgument Bool, locale : OptionalArgument Entur.Enum.Locale.Locale, heuristicStepsPerMainStep : OptionalArgument Int, compactLegsByReversedSearch : OptionalArgument Bool, reverseOptimizeOnTheFly : OptionalArgument Bool, maxPreTransitTime : OptionalArgument Int, preTransitPenalty : OptionalArgument Float, preTransitOverageRate : OptionalArgument Float, preTransitReluctance : OptionalArgument Float, maxPreTransitWalkDistance : OptionalArgument Float, walkBoardCost : OptionalArgument Int, walkReluctance : OptionalArgument Float }


type alias TripRequiredArguments =
    { from : Entur.InputObject.Location, to : Entur.InputObject.Location }


{-| Input type for executing a travel search for a trip between two locations. Returns trip patterns describing suggested alternatives for the trip.

  - dateTime - Date and time for the earliest time the user is willing to start the journey (if arriveBy=false/not set) or the latest acceptable time of arriving (arriveBy=true). Defaults to now
  - from - The start location
  - to - The end location
  - wheelchair - Whether the trip must be wheelchair accessible.
  - numTripPatterns - The maximum number of trip patterns to return.
  - maximumWalkDistance - The maximum distance (in meters) the user is willing to walk. Note that trip patterns with longer walking distances will be penalized, but not altogether disallowed. Maximum allowed value is 15000 m
  - walkSpeed - The maximum walk speed along streets, in meters per second
  - bikeSpeed - The maximum bike speed along streets, in meters per second
  - optimisationMethod - The set of characteristics that the user wants to optimise for -- defaults to quick
  - arriveBy - Whether the trip should depart at dateTime (false, the default), or arrive at dateTime.
  - vias - An ordered list of intermediate locations to be visited.
  - preferred - Parameters for indicating authorities or lines that preferably should be used in trip patters. A cost is applied to boarding nonpreferred authorities or lines (otherThanPreferredRoutesPenalty).
  - unpreferred - Parameters for indicating authorities or lines that preferably should not be used in trip patters. A cost is applied to boarding nonpreferred authorities or lines (otherThanPreferredRoutesPenalty).
  - banned - Parameters for indicating authorities, lines or quays not be used in the trip patterns
  - whiteListed - Parameters for indicating the only authorities, lines or quays to be used in the trip patterns
  - transferPenalty - An extra penalty added on transfers (i.e. all boardings except the first one). The transferPenalty is used when a user requests even less transfers. In the latter case, we don't actually optimise for fewest transfers, as this can lead to absurd results. Consider a trip in New York from Grand Army Plaza (the one in Brooklyn) to Kalustyan's at noon. The true lowest transfers trip pattern is to wait until midnight, when the 4 train runs local the whole way. The actual fastest trip pattern is the 2/3 to the 4/5 at Nevins to the 6 at Union Square, which takes half an hour. Even someone optimise for fewest transfers doesn't want to wait until midnight. Maybe they would be willing to walk to 7th Ave and take the Q to Union Square, then transfer to the 6. If this takes less than transferPenalty seconds, then that's what we'll return.
  - modes - The set of modes that a user is willing to use. Defaults to [air, bus, cableway, water, funicular, lift, rail, metro, tram, coach, transit, foot]
  - transportSubmodes - Optional set of allowed submodes per transport mode provided in 'modes'. If at least one submode is set for a transport mode all submodes not set will be disregarded. Note that transportMode must also be included in 'modes' for the submodes to be allowed
  - allowBikeRental - Is bike rental allowed?
  - minimumTransferTime - A global minimum transfer time (in seconds) that specifies the minimum amount of time that must pass between exiting one public transport vehicle and boarding another. This time is in addition to time it might take to walk between stops.
  - maximumTransfers - Maximum number of transfers
  - ignoreRealtimeUpdates - When true, realtime updates are ignored during this search.
  - includePlannedCancellations - When true, service journeys cancelled in scheduled route data will be included during this search.
  - heuristicStepsPerMainStep - Search algorithm tuning parameter.
  - compactLegsByReversedSearch - Whether legs should be compacted by performing a reversed search. Experimental argument, will be removed!.
  - reverseOptimizeOnTheFly - For debugging only.
  - maxPreTransitTime - Maximum time for the ride part of "kiss and ride" and "ride and kiss".
  - preTransitPenalty - A one time jump in cost for exceeding the maximum time of the ride part of "kiss and ride" and "ride and kiss".
  - preTransitOverageRate - A multiplier in cost when over the maximum time of the ride part of "kiss and ride" and "ride and kiss".
  - preTransitReluctance - How much worse driving before and after transit is than riding on transit. Applies to ride and kiss, kiss and ride and park and ride.
  - maxPreTransitWalkDistance - Max walk distance for access/egress legs.
  - walkBoardCost - DEPRECATED - ONLY FOR TESTING. Cost applied each time transit is boarded.
  - walkReluctance - DEPRECATED - ONLY FOR TESTING. Walk cost is multiplied by this value.

-}
trip : (TripOptionalArguments -> TripOptionalArguments) -> TripRequiredArguments -> SelectionSet decodesTo Entur.Object.Trip -> Field (Maybe decodesTo) RootQuery
trip fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { dateTime = Absent, wheelchair = Absent, numTripPatterns = Absent, maximumWalkDistance = Absent, walkSpeed = Absent, bikeSpeed = Absent, optimisationMethod = Absent, arriveBy = Absent, vias = Absent, preferred = Absent, unpreferred = Absent, banned = Absent, whiteListed = Absent, transferPenalty = Absent, modes = Absent, transportSubmodes = Absent, allowBikeRental = Absent, minimumTransferTime = Absent, maximumTransfers = Absent, ignoreRealtimeUpdates = Absent, includePlannedCancellations = Absent, locale = Absent, heuristicStepsPerMainStep = Absent, compactLegsByReversedSearch = Absent, reverseOptimizeOnTheFly = Absent, maxPreTransitTime = Absent, preTransitPenalty = Absent, preTransitOverageRate = Absent, preTransitReluctance = Absent, maxPreTransitWalkDistance = Absent, walkBoardCost = Absent, walkReluctance = Absent }

        optionalArgs =
            [ Argument.optional "dateTime" filledInOptionals.dateTime (\(Entur.Scalar.DateTime raw) -> Encode.string raw), Argument.optional "wheelchair" filledInOptionals.wheelchair Encode.bool, Argument.optional "numTripPatterns" filledInOptionals.numTripPatterns Encode.int, Argument.optional "maximumWalkDistance" filledInOptionals.maximumWalkDistance Encode.float, Argument.optional "walkSpeed" filledInOptionals.walkSpeed Encode.float, Argument.optional "bikeSpeed" filledInOptionals.bikeSpeed Encode.float, Argument.optional "optimisationMethod" filledInOptionals.optimisationMethod (Encode.enum Entur.Enum.OptimisationMethod.toString), Argument.optional "arriveBy" filledInOptionals.arriveBy Encode.bool, Argument.optional "vias" filledInOptionals.vias (Entur.InputObject.encodeLocation |> Encode.maybe |> Encode.list), Argument.optional "preferred" filledInOptionals.preferred Entur.InputObject.encodeInputPreferred, Argument.optional "unpreferred" filledInOptionals.unpreferred Entur.InputObject.encodeInputUnpreferred, Argument.optional "banned" filledInOptionals.banned Entur.InputObject.encodeInputBanned, Argument.optional "whiteListed" filledInOptionals.whiteListed Entur.InputObject.encodeInputWhiteListed, Argument.optional "transferPenalty" filledInOptionals.transferPenalty Encode.int, Argument.optional "modes" filledInOptionals.modes (Encode.enum Entur.Enum.Mode.toString |> Encode.maybe |> Encode.list), Argument.optional "transportSubmodes" filledInOptionals.transportSubmodes (Entur.InputObject.encodeTransportSubmodeFilter |> Encode.maybe |> Encode.list), Argument.optional "allowBikeRental" filledInOptionals.allowBikeRental Encode.bool, Argument.optional "minimumTransferTime" filledInOptionals.minimumTransferTime Encode.int, Argument.optional "maximumTransfers" filledInOptionals.maximumTransfers Encode.int, Argument.optional "ignoreRealtimeUpdates" filledInOptionals.ignoreRealtimeUpdates Encode.bool, Argument.optional "includePlannedCancellations" filledInOptionals.includePlannedCancellations Encode.bool, Argument.optional "locale" filledInOptionals.locale (Encode.enum Entur.Enum.Locale.toString), Argument.optional "heuristicStepsPerMainStep" filledInOptionals.heuristicStepsPerMainStep Encode.int, Argument.optional "compactLegsByReversedSearch" filledInOptionals.compactLegsByReversedSearch Encode.bool, Argument.optional "reverseOptimizeOnTheFly" filledInOptionals.reverseOptimizeOnTheFly Encode.bool, Argument.optional "maxPreTransitTime" filledInOptionals.maxPreTransitTime Encode.int, Argument.optional "preTransitPenalty" filledInOptionals.preTransitPenalty Encode.float, Argument.optional "preTransitOverageRate" filledInOptionals.preTransitOverageRate Encode.float, Argument.optional "preTransitReluctance" filledInOptionals.preTransitReluctance Encode.float, Argument.optional "maxPreTransitWalkDistance" filledInOptionals.maxPreTransitWalkDistance Encode.float, Argument.optional "walkBoardCost" filledInOptionals.walkBoardCost Encode.int, Argument.optional "walkReluctance" filledInOptionals.walkReluctance Encode.float ]
                |> List.filterMap identity
    in
    Object.selectionField "trip" (optionalArgs ++ [ Argument.required "from" requiredArgs.from Entur.InputObject.encodeLocation, Argument.required "to" requiredArgs.to Entur.InputObject.encodeLocation ]) object_ (identity >> Decode.nullable)


type alias StopPlaceRequiredArguments =
    { id : String }


{-| Get a single stopPlace based on its id)
-}
stopPlace : StopPlaceRequiredArguments -> SelectionSet decodesTo Entur.Object.StopPlace -> Field (Maybe decodesTo) RootQuery
stopPlace requiredArgs object_ =
    Object.selectionField "stopPlace" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias StopPlacesOptionalArguments =
    { ids : OptionalArgument (List (Maybe String)) }


{-| Get all stopPlaces
-}
stopPlaces : (StopPlacesOptionalArguments -> StopPlacesOptionalArguments) -> SelectionSet decodesTo Entur.Object.StopPlace -> Field (List (Maybe decodesTo)) RootQuery
stopPlaces fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { ids = Absent }

        optionalArgs =
            [ Argument.optional "ids" filledInOptionals.ids (Encode.string |> Encode.maybe |> Encode.list) ]
                |> List.filterMap identity
    in
    Object.selectionField "stopPlaces" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias StopPlacesByBboxOptionalArguments =
    { minimumLatitude : OptionalArgument Float, minimumLongitude : OptionalArgument Float, maximumLatitude : OptionalArgument Float, maximumLongitude : OptionalArgument Float, authority : OptionalArgument String, multiModalMode : OptionalArgument Entur.Enum.MultiModalMode.MultiModalMode, filterByInUse : OptionalArgument Bool }


{-| Get all stop places within the specified bounding box

  - multiModalMode - MultiModalMode for query. To control whether multi modal parent stop places, their mono modal children or both are included in the response. Does not affect mono modal stop places that do not belong to a multi modal stop place.
  - filterByInUse - If true only stop places with at least one visiting line are included.

-}
stopPlacesByBbox : (StopPlacesByBboxOptionalArguments -> StopPlacesByBboxOptionalArguments) -> SelectionSet decodesTo Entur.Object.StopPlace -> Field (List (Maybe decodesTo)) RootQuery
stopPlacesByBbox fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { minimumLatitude = Absent, minimumLongitude = Absent, maximumLatitude = Absent, maximumLongitude = Absent, authority = Absent, multiModalMode = Absent, filterByInUse = Absent }

        optionalArgs =
            [ Argument.optional "minimumLatitude" filledInOptionals.minimumLatitude Encode.float, Argument.optional "minimumLongitude" filledInOptionals.minimumLongitude Encode.float, Argument.optional "maximumLatitude" filledInOptionals.maximumLatitude Encode.float, Argument.optional "maximumLongitude" filledInOptionals.maximumLongitude Encode.float, Argument.optional "authority" filledInOptionals.authority Encode.string, Argument.optional "multiModalMode" filledInOptionals.multiModalMode (Encode.enum Entur.Enum.MultiModalMode.toString), Argument.optional "filterByInUse" filledInOptionals.filterByInUse Encode.bool ]
                |> List.filterMap identity
    in
    Object.selectionField "stopPlacesByBbox" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias QuayRequiredArguments =
    { id : String }


{-| Get a single quay based on its id)
-}
quay : QuayRequiredArguments -> SelectionSet decodesTo Entur.Object.Quay -> Field (Maybe decodesTo) RootQuery
quay requiredArgs object_ =
    Object.selectionField "quay" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias QuaysOptionalArguments =
    { ids : OptionalArgument (List (Maybe String)), name : OptionalArgument String }


{-| Get all quays
-}
quays : (QuaysOptionalArguments -> QuaysOptionalArguments) -> SelectionSet decodesTo Entur.Object.Quay -> Field (List (Maybe decodesTo)) RootQuery
quays fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { ids = Absent, name = Absent }

        optionalArgs =
            [ Argument.optional "ids" filledInOptionals.ids (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "name" filledInOptionals.name Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionField "quays" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias QuaysByBboxOptionalArguments =
    { minimumLatitude : OptionalArgument Float, minimumLongitude : OptionalArgument Float, maximumLatitude : OptionalArgument Float, maximumLongitude : OptionalArgument Float, authority : OptionalArgument String, filterByInUse : OptionalArgument Bool }


{-| Get all quays within the specified bounding box

  - filterByInUse - If true only quays with at least one visiting line are included.

-}
quaysByBbox : (QuaysByBboxOptionalArguments -> QuaysByBboxOptionalArguments) -> SelectionSet decodesTo Entur.Object.Quay -> Field (List (Maybe decodesTo)) RootQuery
quaysByBbox fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { minimumLatitude = Absent, minimumLongitude = Absent, maximumLatitude = Absent, maximumLongitude = Absent, authority = Absent, filterByInUse = Absent }

        optionalArgs =
            [ Argument.optional "minimumLatitude" filledInOptionals.minimumLatitude Encode.float, Argument.optional "minimumLongitude" filledInOptionals.minimumLongitude Encode.float, Argument.optional "maximumLatitude" filledInOptionals.maximumLatitude Encode.float, Argument.optional "maximumLongitude" filledInOptionals.maximumLongitude Encode.float, Argument.optional "authority" filledInOptionals.authority Encode.string, Argument.optional "filterByInUse" filledInOptionals.filterByInUse Encode.bool ]
                |> List.filterMap identity
    in
    Object.selectionField "quaysByBbox" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias QuaysByRadiusOptionalArguments =
    { latitude : OptionalArgument Float, longitude : OptionalArgument Float, radius : OptionalArgument Int, authority : OptionalArgument String, before : OptionalArgument String, after : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


{-| Get all quays within the specified radius from a location. The returned type has two fields quay and distance

  - latitude - Latitude of the location
  - longitude - Longitude of the location
  - radius - Radius (in meters) to search for from the specified location
  - before - fetching only nodes before this node (exclusive)
  - after - fetching only nodes after this node (exclusive)
  - first - fetching only the first certain number of nodes
  - last - fetching only the last certain number of nodes

-}
quaysByRadius : (QuaysByRadiusOptionalArguments -> QuaysByRadiusOptionalArguments) -> SelectionSet decodesTo Entur.Object.QuayAtDistanceConnection -> Field (Maybe decodesTo) RootQuery
quaysByRadius fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { latitude = Absent, longitude = Absent, radius = Absent, authority = Absent, before = Absent, after = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "latitude" filledInOptionals.latitude Encode.float, Argument.optional "longitude" filledInOptionals.longitude Encode.float, Argument.optional "radius" filledInOptionals.radius Encode.int, Argument.optional "authority" filledInOptionals.authority Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "quaysByRadius" optionalArgs object_ (identity >> Decode.nullable)


type alias NearestOptionalArguments =
    { maximumDistance : OptionalArgument Int, maximumResults : OptionalArgument Int, filterByPlaceTypes : OptionalArgument (List (Maybe Entur.Enum.FilterPlaceType.FilterPlaceType)), filterByModes : OptionalArgument (List (Maybe Entur.Enum.Mode.Mode)), filterByInUse : OptionalArgument Bool, filterByIds : OptionalArgument Entur.InputObject.InputFilters, multiModalMode : OptionalArgument Entur.Enum.MultiModalMode.MultiModalMode, before : OptionalArgument String, after : OptionalArgument String, first : OptionalArgument Int, last : OptionalArgument Int }


type alias NearestRequiredArguments =
    { latitude : Float, longitude : Float }


{-| Get all places (quays, stop places, car parks etc. with coordinates) within the specified radius from a location. The returned type has two fields place and distance. The search is done by walking so the distance is according to the network of walkables.

  - latitude - Latitude of the location
  - longitude - Longitude of the location
  - maximumDistance - Maximum distance (in meters) to search for from the specified location. Default is 2000m.
  - maximumResults - Maximum number of results. Search is stopped when this limit is reached. Default is 20.
  - filterByPlaceTypes - Only include places that imply this type. i.e. mode for quay, stop place etc. Also BICYCLE\_RENT for bike rental stations.
  - filterByModes - Only include places that include this mode. Only checked for places with mode i.e. quays, departures.
  - filterByInUse - Only affects queries for quays and stop places. If true only quays and stop places with at least one visiting line are included.
  - filterByIds - Only include places that match one of the given ids.
  - multiModalMode - MultiModalMode for query. To control whether multi modal parent stop places, their mono modal children or both are included in the response. Does not affect mono modal stop places that do not belong to a multi modal stop place. Only applicable for placeType StopPlace
  - before - fetching only nodes before this node (exclusive)
  - after - fetching only nodes after this node (exclusive)
  - first - fetching only the first certain number of nodes
  - last - fetching only the last certain number of nodes

-}
nearest : (NearestOptionalArguments -> NearestOptionalArguments) -> NearestRequiredArguments -> SelectionSet decodesTo Entur.Object.PlaceAtDistanceConnection -> Field (Maybe decodesTo) RootQuery
nearest fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { maximumDistance = Absent, maximumResults = Absent, filterByPlaceTypes = Absent, filterByModes = Absent, filterByInUse = Absent, filterByIds = Absent, multiModalMode = Absent, before = Absent, after = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "maximumDistance" filledInOptionals.maximumDistance Encode.int, Argument.optional "maximumResults" filledInOptionals.maximumResults Encode.int, Argument.optional "filterByPlaceTypes" filledInOptionals.filterByPlaceTypes (Encode.enum Entur.Enum.FilterPlaceType.toString |> Encode.maybe |> Encode.list), Argument.optional "filterByModes" filledInOptionals.filterByModes (Encode.enum Entur.Enum.Mode.toString |> Encode.maybe |> Encode.list), Argument.optional "filterByInUse" filledInOptionals.filterByInUse Encode.bool, Argument.optional "filterByIds" filledInOptionals.filterByIds Entur.InputObject.encodeInputFilters, Argument.optional "multiModalMode" filledInOptionals.multiModalMode (Encode.enum Entur.Enum.MultiModalMode.toString), Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionField "nearest" (optionalArgs ++ [ Argument.required "latitude" requiredArgs.latitude Encode.float, Argument.required "longitude" requiredArgs.longitude Encode.float ]) object_ (identity >> Decode.nullable)


type alias AuthorityRequiredArguments =
    { id : String }


{-| Get an authority by ID
-}
authority : AuthorityRequiredArguments -> SelectionSet decodesTo Entur.Object.Authority -> Field (Maybe decodesTo) RootQuery
authority requiredArgs object_ =
    Object.selectionField "authority" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


{-| Get all authorities
-}
authorities : SelectionSet decodesTo Entur.Object.Authority -> Field (List (Maybe decodesTo)) RootQuery
authorities object_ =
    Object.selectionField "authorities" [] object_ (identity >> Decode.nullable >> Decode.list)


type alias OperatorRequiredArguments =
    { id : String }


{-| Get a operator by ID
-}
operator : OperatorRequiredArguments -> SelectionSet decodesTo Entur.Object.Operator -> Field (Maybe decodesTo) RootQuery
operator requiredArgs object_ =
    Object.selectionField "operator" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


{-| Get all operators
-}
operators : SelectionSet decodesTo Entur.Object.Operator -> Field (List (Maybe decodesTo)) RootQuery
operators object_ =
    Object.selectionField "operators" [] object_ (identity >> Decode.nullable >> Decode.list)


type alias OrganisationRequiredArguments =
    { id : String }


organisation : OrganisationRequiredArguments -> SelectionSet decodesTo Entur.Object.Organisation -> Field (Maybe decodesTo) RootQuery
organisation requiredArgs object_ =
    Object.selectionField "organisation" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


organisations : SelectionSet decodesTo Entur.Object.Organisation -> Field (List (Maybe decodesTo)) RootQuery
organisations object_ =
    Object.selectionField "organisations" [] object_ (identity >> Decode.nullable >> Decode.list)


type alias LineRequiredArguments =
    { id : String }


{-| Get a single line based on its id
-}
line : LineRequiredArguments -> SelectionSet decodesTo Entur.Object.Line -> Field (Maybe decodesTo) RootQuery
line requiredArgs object_ =
    Object.selectionField "line" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias LinesOptionalArguments =
    { ids : OptionalArgument (List (Maybe String)), name : OptionalArgument String, publicCode : OptionalArgument String, publicCodes : OptionalArgument (List (Maybe String)), transportModes : OptionalArgument (List (Maybe Entur.Enum.TransportMode.TransportMode)), authorities : OptionalArgument (List (Maybe String)) }


{-| Get all lines

  - authorities - Set of ids of authorities to fetch lines for.

-}
lines : (LinesOptionalArguments -> LinesOptionalArguments) -> SelectionSet decodesTo Entur.Object.Line -> Field (List (Maybe decodesTo)) RootQuery
lines fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { ids = Absent, name = Absent, publicCode = Absent, publicCodes = Absent, transportModes = Absent, authorities = Absent }

        optionalArgs =
            [ Argument.optional "ids" filledInOptionals.ids (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "name" filledInOptionals.name Encode.string, Argument.optional "publicCode" filledInOptionals.publicCode Encode.string, Argument.optional "publicCodes" filledInOptionals.publicCodes (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "transportModes" filledInOptionals.transportModes (Encode.enum Entur.Enum.TransportMode.toString |> Encode.maybe |> Encode.list), Argument.optional "authorities" filledInOptionals.authorities (Encode.string |> Encode.maybe |> Encode.list) ]
                |> List.filterMap identity
    in
    Object.selectionField "lines" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias ServiceJourneyRequiredArguments =
    { id : String }


{-| Get a single service journey based on its id
-}
serviceJourney : ServiceJourneyRequiredArguments -> SelectionSet decodesTo Entur.Object.ServiceJourney -> Field (Maybe decodesTo) RootQuery
serviceJourney requiredArgs object_ =
    Object.selectionField "serviceJourney" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias ServiceJourneysOptionalArguments =
    { lines : OptionalArgument (List (Maybe String)), privateCodes : OptionalArgument (List (Maybe String)), activeDates : OptionalArgument (List (Maybe Entur.Scalar.Date)), authorities : OptionalArgument (List (Maybe String)) }


{-| Get all service journeys

  - lines - Set of ids of lines to fetch serviceJourneys for.
  - privateCodes - Set of ids of private codes to fetch serviceJourneys for.
  - activeDates - Set of ids of active dates to fetch serviceJourneys for.
  - authorities - Set of ids of authorities to fetch serviceJourneys for.

-}
serviceJourneys : (ServiceJourneysOptionalArguments -> ServiceJourneysOptionalArguments) -> SelectionSet decodesTo Entur.Object.ServiceJourney -> Field (List (Maybe decodesTo)) RootQuery
serviceJourneys fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { lines = Absent, privateCodes = Absent, activeDates = Absent, authorities = Absent }

        optionalArgs =
            [ Argument.optional "lines" filledInOptionals.lines (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "privateCodes" filledInOptionals.privateCodes (Encode.string |> Encode.maybe |> Encode.list), Argument.optional "activeDates" filledInOptionals.activeDates ((\(Entur.Scalar.Date raw) -> Encode.string raw) |> Encode.maybe |> Encode.list), Argument.optional "authorities" filledInOptionals.authorities (Encode.string |> Encode.maybe |> Encode.list) ]
                |> List.filterMap identity
    in
    Object.selectionField "serviceJourneys" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


{-| Get a single bike rental station based on its id
-}
bikeRentalStations : SelectionSet decodesTo Entur.Object.BikeRentalStation -> Field (List (Maybe decodesTo)) RootQuery
bikeRentalStations object_ =
    Object.selectionField "bikeRentalStations" [] object_ (identity >> Decode.nullable >> Decode.list)


type alias BikeRentalStationRequiredArguments =
    { id : String }


{-| Get all bike rental stations
-}
bikeRentalStation : BikeRentalStationRequiredArguments -> SelectionSet decodesTo Entur.Object.BikeRentalStation -> Field (Maybe decodesTo) RootQuery
bikeRentalStation requiredArgs object_ =
    Object.selectionField "bikeRentalStation" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias BikeRentalStationsByBboxOptionalArguments =
    { minimumLatitude : OptionalArgument Float, minimumLongitude : OptionalArgument Float, maximumLatitude : OptionalArgument Float, maximumLongitude : OptionalArgument Float }


{-| Get all bike rental stations within the specified bounding box.
-}
bikeRentalStationsByBbox : (BikeRentalStationsByBboxOptionalArguments -> BikeRentalStationsByBboxOptionalArguments) -> SelectionSet decodesTo Entur.Object.BikeRentalStation -> Field (List (Maybe decodesTo)) RootQuery
bikeRentalStationsByBbox fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { minimumLatitude = Absent, minimumLongitude = Absent, maximumLatitude = Absent, maximumLongitude = Absent }

        optionalArgs =
            [ Argument.optional "minimumLatitude" filledInOptionals.minimumLatitude Encode.float, Argument.optional "minimumLongitude" filledInOptionals.minimumLongitude Encode.float, Argument.optional "maximumLatitude" filledInOptionals.maximumLatitude Encode.float, Argument.optional "maximumLongitude" filledInOptionals.maximumLongitude Encode.float ]
                |> List.filterMap identity
    in
    Object.selectionField "bikeRentalStationsByBbox" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias BikeParkRequiredArguments =
    { id : String }


{-| Get a single bike park based on its id
-}
bikePark : BikeParkRequiredArguments -> SelectionSet decodesTo Entur.Object.BikePark -> Field (Maybe decodesTo) RootQuery
bikePark requiredArgs object_ =
    Object.selectionField "bikePark" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


{-| Get all bike parks
-}
bikeParks : SelectionSet decodesTo Entur.Object.BikePark -> Field (List (Maybe decodesTo)) RootQuery
bikeParks object_ =
    Object.selectionField "bikeParks" [] object_ (identity >> Decode.nullable >> Decode.list)


type alias CarParkRequiredArguments =
    { id : String }


{-| Get a single car park based on its id
-}
carPark : CarParkRequiredArguments -> SelectionSet decodesTo Entur.Object.CarPark -> Field (Maybe decodesTo) RootQuery
carPark requiredArgs object_ =
    Object.selectionField "carPark" [ Argument.required "id" requiredArgs.id Encode.string ] object_ (identity >> Decode.nullable)


type alias CarParksOptionalArguments =
    { ids : OptionalArgument (List (Maybe String)) }


{-| Get all car parks
-}
carParks : (CarParksOptionalArguments -> CarParksOptionalArguments) -> SelectionSet decodesTo Entur.Object.CarPark -> Field (List (Maybe decodesTo)) RootQuery
carParks fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { ids = Absent }

        optionalArgs =
            [ Argument.optional "ids" filledInOptionals.ids (Encode.string |> Encode.maybe |> Encode.list) ]
                |> List.filterMap identity
    in
    Object.selectionField "carParks" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


{-| Get default routing parameters.
-}
routingParameters : SelectionSet decodesTo Entur.Object.RoutingParameters -> Field (Maybe decodesTo) RootQuery
routingParameters object_ =
    Object.selectionField "routingParameters" [] object_ (identity >> Decode.nullable)


{-| Get all notices
-}
notices : SelectionSet decodesTo Entur.Object.Notice -> Field (List (Maybe decodesTo)) RootQuery
notices object_ =
    Object.selectionField "notices" [] object_ (identity >> Decode.nullable >> Decode.list)


{-| Get all active situations
-}
situations : SelectionSet decodesTo Entur.Object.PtSituationElement -> Field (List (Maybe decodesTo)) RootQuery
situations object_ =
    Object.selectionField "situations" [] object_ (identity >> Decode.nullable >> Decode.list)
